import { describe, it } from "mocha";
import assert from "assert";
import { matrixMul, generateBinaryWords } from "../lib/index.js";
import LinearCode from "./LinearCode.js";

describe("LinearCode", () => {
  it("Testing LinearCode class from manual", () => {
    /**
     * 1.3 –°–æ–∑–¥–∞—Ç—å –∫–ª–∞—Å—Å –ª–∏–Ω–µ–π–Ω—ã—Ö –∫–æ–¥–æ–≤ LinearCode.
     */
    const linearCode = new LinearCode([
      [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],
      [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0],
      [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
      [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0],
      [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
    ]);
    /**
     * 1.3.1 –ù–∞ –æ—Å–Ω–æ–≤–µ –≤—Ö–æ–¥–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä–æ–∂–¥–∞—é—â—É—é –º–∞—Ç—Ä–∏—Ü—É –≤ —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º * –≤–∏–¥–µ.
     */
    assert.deepEqual(linearCode.S, [
      [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],
      [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0],
      [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);
    /**
     * 1.3.2 –ó–∞–¥–∞—Ç—å n —Ä–∞–≤–Ω–æ–µ —á–∏—Å–ª—É —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ k —Ä–∞–≤–Ω–æ–µ —á–∏—Å–ª—É —Å—Ç—Ä–æ–∫ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã * (–±–µ–∑ —É—á—ë—Ç–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω—É–ª–µ–≤—ã—Ö —Å—Ç—Ä–æ–∫).
     */
    assert.strictEqual(linearCode.k, 5);
    assert.strictEqual(linearCode.n, 11);
    /**
     * 1.3.3 –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–æ—á–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ—Ä–æ–∂–¥–∞—é—â–µ–π.
     */
    assert.deepEqual(linearCode.G, [
      [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],
      [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0],
      [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    ]);
    /**
     * 1.3.3 –®–∞–≥ 1. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É ùêÜ‚àó –≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ
     * –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ—Ä–æ–∂–¥–∞—é—â–µ–π.
     */
    const G_TEST = linearCode.getTestMatrix();
    assert.deepEqual(G_TEST, [
      [1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0],
      [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1],
      [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    ]);
    /**
     * 1.3.3 –®–∞–≥ 2. –ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –≤–µ–¥—É—â–∏–µ —Å—Ç–æ–ª–±—Ü—ã lead –º–∞—Ç—Ä–∏—Ü—ã ùêÜ‚àó.
     */
    assert.deepEqual(linearCode.getLeadColsIndexes(), [0, 3, 4, 6, 8]);
    /**
     * 1.3.3 –®–∞–≥ 3. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Å–æ–∫—Ä–∞—â—ë–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É ùêó, —É–¥–∞–ª–∏–≤ –≤–µ–¥—É—â–∏–µ
     * —Å—Ç–æ–ª–±—Ü—ã –º–∞—Ç—Ä–∏—Ü—ã ùêÜ‚àó.
     */
    const reducedG = linearCode.getReducedG();
    assert.deepEqual(reducedG, [
      [0, 1, 1, 1, 1, 0],
      [0, 0, 1, 0, 1, 1],
      [0, 0, 0, 1, 0, 1],
      [0, 0, 0, 0, 1, 1],
      [0, 0, 0, 0, 1, 1],
    ]);
    /**
     * 1.3.3 –®–∞–≥ 4. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É ùêá, –ø–æ–º–µ—Å—Ç–∏–≤ –≤ —Å—Ç—Ä–æ–∫–∏, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–æ–∑–∏—Ü–∏—è–º –≤–µ–¥—É—â–∏—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ —Å—Ç—Ä–æ–∫–∏ –∏–∑ ùêó, –∞ –≤
–æ—Å—Ç–∞–ª—å–Ω—ã–µ ‚Äì —Å—Ç—Ä–æ–∫–∏ –µ–¥–∏–Ω–∏—á–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã.
     */
    const H = linearCode.getH();
    assert.deepEqual(H, [
      [0, 1, 1, 1, 1, 0],
      [1, 0, 0, 0, 0, 0],
      [0, 1, 0, 0, 0, 0],
      [0, 0, 1, 0, 1, 1],
      [0, 0, 0, 1, 0, 1],
      [0, 0, 1, 0, 0, 0],
      [0, 0, 0, 0, 1, 1],
      [0, 0, 0, 1, 0, 0],
      [0, 0, 0, 0, 1, 1],
      [0, 0, 0, 0, 1, 0],
      [0, 0, 0, 0, 0, 1],
    ]);
    /**
     * 1.4 –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –∫–æ–¥–æ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª–∏–Ω—ã n –¥–≤—É–º—è —Å–ø–æ—Å–æ–±–∞–º–∏.
     */
    /**
     * 1.4.1 –°–ª–æ–∂–∏—Ç—å –≤—Å–µ —Å–ª–æ–≤–∞ –∏–∑ –ø–æ—Ä–æ–∂–¥–∞—é—â–µ–≥–æ –º–Ω–æ–∂–µ—Å—Ç–≤–∞, –æ—Å—Ç–∞–≤–∏—Ç—å –Ω–µ–ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è.
     */
    // const allWords = linearCode.getWords();
    // console.table(allWords);
    /**
     * 1.4.2 –í–∑—è—Ç—å –≤—Å–µ –¥–≤–æ–∏—á–Ω—ã–µ —Å–ª–æ–≤–∞ –¥–ª–∏–Ω—ã k, —É–º–Ω–æ–∂–∏—Ç—å –∫–∞–∂–¥–æ–µ –Ω–∞ G.
     */
    const u = [[1, 0, 1, 1, 0]];
    const v = matrixMul(u, linearCode.G);
    assert.deepEqual(v, [[1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1]]);
    assert.deepEqual(matrixMul(v, H), [[0, 0, 0, 0, 0, 0]]);
    const binaryWords = [];
    generateBinaryWords(
      new Array(linearCode.k).fill(0),
      linearCode.k,
      0,
      binaryWords
    );
    const allWordsV2 = matrixMul(binaryWords, linearCode.G);
    console.table(allWordsV2);
    /**
     * 1.4 –í—ã—á–∏—Å–ª–∏—Ç—å –∫–æ–¥–æ–≤–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—É—á–∏–≤—à–µ–≥–æ—Å—è –∫–æ–¥–∞.
     */
    let d = Number.MAX_SAFE_INTEGER;
    for (let i = 0; i < linearCode.G.length; ++i) {
      for (let j = i + 1; j < linearCode.G.length; ++j) {
        let difference = 0;
        linearCode.G[i].forEach((num, idx) => {
          if (num !== linearCode.G[j][idx]) {
            difference++;
          }
        });
        d = Math.min(d, difference);
      }
    }
    assert.strictEqual(d, 2);
    const t = d - 1;
    assert.strictEqual(t, 1);
    v[0][2] = (v[0][2] + 1) % 2;
    assert.deepEqual(matrixMul(v, H), [[0, 1, 0, 0, 0, 0]]);
    // v[0][2] = (v[0][2] + 1) % 2;
    // v[0][4] = (v[0][4] + 1) % 2;
    // v[0][7] = (v[0][7] + 1) % 2;
    // console.table(matrixMul(v, H));
    // assert.deepEqual(matrixMul(v, H), [[0, 0, 0, 0, 0, 0]]);
  });
});
